\documentclass[14pt]{diploma}

\input{preamble}

\begin{document}

<<<<<<< HEAD
\include{title}
\include{task}
\newpage
\tableofcontents
\include{intro}
\include{simplex}
\include{parallel}
\include{impl}
\input{outro}
\input{append}
\input{biblio}
=======
\maketitle

\begin{abstract}
В большинстве случаев симплекс-метод является самым эффективным методом
решения задач линейного программирования (ЗЛП). В работе рассматриваются
существующие попытки распараллеливания симплекс-метода по отношению к
эффективной последовательной реализации и характеру практических ЗЛП.
Для решения разреженных ЗЛП большой размерности не существует параллельной
реализации симплекс-метода, значительно превосходящей по производительности
хорошую последовательную реализацию. Хотя существует некоторый прогресс
в разработке параллельных реализаций для неразреженных ЗЛП или ЗЛП,
не имеющих особых структурных свойств. Как результат такого обзора,
эта работа определяет направления будущих исследований в области разработки
параллельных реализаций симплекс-метода, имеющих практическое значение.

Ключевые слова: линейное программирование, симплекс-метод, разреженная
матрица, пораллельные вычисления.
\end{abstract}

\section{Введение}

Задачи линейного программирования (ЗЛП) возникают из различных областей науки,
в т.ч. и как промежуточные этапы при решении других оптимизационных задач.
Симплекс-метод и методы внутренней точки являются двумя главными подходами
для решения ЗЛП. В случаях, когда решаются семейства взаимосвязанных ЗЛП
(целочисленное программирование, методы разложения, некоторые классы задач
линейного программирования), симплекс-метод обычно более эффективен.

Механизмы применения параллельной и векторной обработки к симплекс-методу для
решения ЗЛП стали обсуждаться с 1970-х гг., хотя первые попытки разработать
практические реализации были предприняты только с начала 1980-х гг.
Наибольшая активность в этом направлении наблюдалась с середины 1980-х до
середины 1990-х гг. Также предпринимались эксперименты использования векторной
обработки данных и ЭВМ с общей разделяемой памятью, подавляющее большинство
реализаций использовали мультипроцессоры с распределенной памятью
и сетевые кластеры.

\section{Симплекс-метод}
\label{simplex}

Симплекс--метод и его требования в вычислительному процессу наиболее удобно
обсуждать в контексте ЗЛП в стандартной форме

\begin{equation}\label{eq:LP}
\begin{array}{l}
c^Tx\rightarrow\min\\
Ax=b\\
x\ge 0,\\
\end{array}
\end{equation}

\noindent где~$x\in\mathbb{R}^n$, $b\in\mathbb{R}^m$. Матрица~$A$
в~(\ref{eq:LP}) обычно содержит столбцы с единицами, соответствующими
фиктивным переменным, возникающим при переводе ограничений-неравенств в
равенства. Оставшиеся столбцы~$A$ соответствуют обычным переменным.

В симплекс-методе индексы переменных подразделяются на два подмножества:
$\mathcal{B}$, соответствующее~$m$ базисным переменным~$x_B$,
и~$\mathcal{N}$, соответствующее~$n-m$ небазисным переменным~$x_N$.
При этом базисная матрица~$B$, составленная из столбцов~$A$,
соответствующих~$\mathcal{B}$, является невырожденной.
Множество~$\mathcal{B}$ условно называют базисом. Столбцы~$A$,
соответствующие~$\mathcal{N}$, формируют матрицу~$N$. Компоненты~$c$,
соответствующие~$\mathcal{B}$ и~$\mathcal{N}$, называют базисными
издержками~$c_B$ и небазисными издержками~$c_N$.

Когда небазисные переменные нулевые, значения~$\hat b=B^{-1}b$ базисных
переменных соответствуют вершинам допустимого региона при условии, что
они неотрицательны. Выражение~$x_B+B^{-1}N=\hat b$, следующее из~(\ref{eq:LP}),
позволяет убрать базисные переменные из целевой функции, которая
становится~$(c_N^T-c_B^TB^{-1}N)x_N+c_B^T\hat b$. Если все
компоненты вектора альтернативных издержек~$\hat c_N=c_N^T-c_B^TB^{-1}N$
неотрицательны, то текущий базис оптимален.

На каждой итерация симплекс-метода, если текущий базис неоптимален,
выбирается небазисная переменная~$x_q$ с отрицательной альтернативной издержкой
для ввода в базис. Увеличение этой переменной от нуля при выполнении
условий~~(\ref{eq:LP}) соответствует перемещению вдоль ребра допустимого
региона в направлении уменьшения значения целевой функции. Направление
этого ребра определяется столбцом~$\hat a_q$ при~$\hat N=B^{-1}N$,
соответствующим~$x_q$. При просмотре отношений компонентов вектора~$\hat b$
к соответствующим положительным компонентам~$\hat a_q$ находится первая
базисная переменная для обнуления при росте~$x_q$ и, следовательно,
шаг к следующей точке допустимого региона вдоль этого ребра.

Существует много стратегий выбора переменной~$x_q$ для ввода в базис.
Первоначальное правило выбора переменной с наименьшей альтернативной
издержкой известно как критерий Данцига. Хотя, если компоненты~$\hat a_j$
намного превосходят компоненты~$\hat c_j$, только небольшое увеличение~$x_j$
возможно до того, как одна из базисных переменных обратится в ноль.
Другие стратегии выбора взвешивают альтернативную издержку путем
деления на длину~$\hat a_j$. Точная стратегия выбора ребра [TODO: REF]
оперирует весами~$s_j=1+||\hat a_j||^2$, соответствующими длине шага
при единичном увеличении~$x_j$. Приближенные (применяемые на практике)
техники [TODO: REF] и [TODO: REF] оперируют приближенными весами ребер.
При использовании этих стратегий количество итераций, необходимых для
решения ЗЛП, на практике может быть оценено как $O(m+n)$, и не выявлены
проблемы, мешающие достижению теоретической сложности $O(2^n)$.

Одной из широко распространенных способов выбора выводимой из базиса переменной
является процедура $EXPAND$ [TODO: REF]. С помощью небольшого расширения
ограничений эта стратегия позволяет выбрать выводимую переменную из набора
возможных на основании численной стабильности.

Существуют две основных варианта симплекс-метода, использующие различные данные
для перехода к следующей вершине. В стандартном симплекс-методе альтернативные
издержки и направления всех ребер в текущей точке хранятся в прямоугольной
таблице. В методе обратной матрицы альтернативные издержки и направления
выбранного ребра определяются решением системы с участием базисной матрицы~$B$.

\subsection{Табличный симплекс-метод}
\label{tableau-simplex}

В табличном симплекс-методе матрица~$\hat N$ вектор~$\hat b$, альтернативные
издержеки~$\hat c_N$ и текущее значение целевой функции~$\hat f=c_B^T\hat b$
хранятся в таблице, общий вид которой показан в таблице~\ref{tab:tableau-simplex}.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|} \hline
& $\mathcal{N}$ & RHS \\ \hline
$\mathcal{B}$ & $\hat N$ & $\hat b$ \\ \hline
& $\hat c_N^T$ & $-\hat f$ \\ \hline
\end{tabular}
\caption{Структура хранения данных табличного симплекс-метода\label{tab:tableau-simplex}}
\end{table}

Каждая итерация метода требует применения преобразований Жордана-Гаусса
к столбцам таблицы таким образом, что новая таблица соответствует новому базису.

Обычно симплекс-метод начинается с базиса, для которого~$B=E$, следовательно
матрица соответствует~$N$. Как результат, таблица является разреженной.
Как правило полагается, что существует достаточная степень заполненности
матрицы после выполняемых преобразований. Как результат, табличный
симплекс-метод реализуется с использованием плотных структур данных.

Табличный симплекс-метод по существу является численно нестабильным, поскольку
необходимо выполнять длительную последовательность исключений с операциями
поворота, определенными алгоритмом метода, а не соображениями численной
эффективности. Если симплекс-метод имеет дело с плохо обусловленными
базисными матрицами, то ожидается, что любая подпоследовательность
таблицы~\ref{tab:tableau-simplex} будет соответствовать хорошо обусловленному
базису для получения ошибок вычисления, отражающих первоначальную
плохую обусловленность. Это может привести к выборам вводимых или выводимых
переменных таких, что при точных вычислениях, целевая функция уменьшается
немонотонно, сходимость теряется либо базисная матрица становится вырожденной.
Надежность может быть достигнута только при отслеживании ошибок в таблице и,
при необходимости, пересчете таблицы численно стабильным способом. Обнаружение
ошибок можно осуществить сравнением нового значения альтернативной издержки с
значением, вычисленным напрямую с использованием столбца поворота и базисных
издержек. С другой стороны, поскольку операции с обратной базисной матрицей
могут быть выполнены с использованием подходящих элементов таблицы, вычисление
столбца поворота может предоставить более расширенный, но с вычислительной
точки зрения более дорогой механизм отслеживания ошибок.

\subsection{Метод обратной матрицы}
\label{revised-simplex}

Алгоритм метода обратной матрицы представлен ниже [TODO: REF]. В начале каждой
итерации предполагается, что вектор альтернативных издержек~$\hat c_N$ и
вектор~$\hat b$ текущих значений базисных переменных известны и
представление~$B^{-1}$. Первая операция~$CHUZC$ ищет среди (взвешенных)
альтернативных издержек хороший кандидат~$q$ для ввода в базис. \textit{Столбец
поворота}~$\hat a_q$ формируется с использованием представления~$B^{-1}$ на
шаге~$FTRAN$.

Операция~$CHUZR$ определяет переменную, выводимую из базиса, используя~$p$ для
обозначения индекса \textit{строки поворота}, содержащей выводимую переменную.
Индекс самой переменной обозначается как~$p'$. После того, как индексы~$q$
и~$p'$ поменяются местами между множествами~$\mathcal{B}$ и~$\mathcal{N}$,
говорят, что произошло \textit{измененение базиса}. Правый вектор-столбец~$\hat b$
обновляется в соответствовии с увеличением~$\alpha=\hat b_p/\hat a_{pq}$ в~$x_q$.

$CHUZC$: Среди~$\hat c_N$ найти хорошего кандидата~$q$ для ввода в базис.

$FTRAN$: Построить столбец поворота~$\hat a_q=B^{-1}a_q$, где~$a_q$ --
столбец~$q$ матрицы~$A$.

$CHUZR$: Среди отношений~$\hat b_i/\hat a_{iq}$ для строки~$p$ найти хорошего
кандидата для вывода из базиса. Положить~$\alpha=\hat b_p/\hat a_{pq}$.
Обновить~$\hat b:=\hat b-\alpha\hat\alpha_q$.

$BTRAN$: Построить~$\pi_p^T=e_p^TB^{-1}$.

$PRICE$: Построить строку поворота~$\hat\alpha_p^T=\pi_p^TN$. Обновить
альтернативные издержки~$\hat c_N^T:=\hat c_N^T-\hat c_q\hat\alpha_p^T$.

Если \{есть рост в представлении~$B$\}

$INSERT$: Построить новое представление~$B^{-1}$.

иначе

$UPDATE$: Обновить представление~$B^{-1}$, соответствующее измененению базиса.

Перед выполнением следующей итерации необходимо вычислить альтернативные
издержки и представление обратной матрицы~$B^{-1}$. Альтернативные издержки
могут быть полужены напрямую используя следующие операции,

\begin{equation}
\pi_B^T=c_B^TB^{-1}; \hat c_N^T=c_N^T-\pi_B^TN,
\end{equation}

которые вычислительно более эффективны при формировании строки
поворота~$\hat\alpha_p^T=e_p^TB^{-1}N$ табличного симплекс-метода. Это
достигается за два шага. Сначала, используя представление~$B^{-1}$ на
шаге~$BTRAN$, строится вектор~$\pi_p^T=e_p^TB^{-1}$. Потом вычисляется вектор
значений~$\hat\alpha_p^T=\pi_p^TN$. Этот разреженный результат используется
как~$N$ в операции~$PRICE$. После того, как альтернативные издержки были
обновлены, на операции~$UPDATE$ изменяет представление~$B^{-1}$ в
соответствии с изменением базиса. Заметим, что периодически (в общем случае),
более эффективно или даже необходимо для численной стабильности получать
новое представление~$B^{-1}$ используя операцию~$INVERT$.

В стратегии Devex~[TODO: REF] строка поворота, вычисленная для обновления
альтернативных издержек, используется для обновления Devex весов при
незначительных вычислительных затратах. Для получения точных весов наибольшего
ребра требуется, помимо строки поворота, дополнительная операция~$BTRAN$ для
вычисления~$\hat a_q^TB^{-1}$ и операция~$PRICE$ для получения продукта этого
вектора с~$N$. Это также вычислительно дорого инициализировать наибольшее
ребро, если начальный базис не является единичной матрицей. Результатом таких
накладных расходов, а также того, что стратегия Devex значительно сокращает
количество итераций, необходимых для решения ЗЛП, Devex обычно используется
в эффективных последовательных реализациях метода обратной матрицы.
>>>>>>> 16758500adda8d8411fa58ddc574e12bd53e43e6

\end{document}
